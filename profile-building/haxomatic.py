import bisect
import itertools
import sys
import os.path

from collections import deque, namedtuple
from typing import Callable, List

from capstone import *

CodePatternMatch = namedtuple("CodePatternMatch", "matched_instructions start_address start_offset")
SentinelInstruction = namedtuple("SentinelInstruction", "address size")

class CodePatternFinder(object):
    def __init__(self, code: bytes, base_address: int = 0):
        self.code = code
        self.base_address = base_address
        self.thumb_cache = self.__build_cache(thumb_mode=True)
        self.arm_cache = self.__build_cache(thumb_mode=False)

    def search(self, condition_lambdas: List[Callable[[CsInsn, int], bool]], start_address: int = None, thumb_mode: bool = True, stop_at_first: bool = True, after_match_count: int = None) -> List[CodePatternMatch]:
        cache = self.thumb_cache if thumb_mode else self.arm_cache
        wordsize = self.__get_wordsize(thumb_mode)

        if start_address is None:
            start_address = self.base_address

        if start_address < self.base_address:
            raise ValueError(f"Starting address 0x{start_address:X} cannot be less than base address 0x{self.base_address:X}")

        if start_address > self.base_address + len(self.code):
            raise ValueError(f"Starting address 0x{start_address:X} is higher the end of code address")

        if (start_address % wordsize) != 0:
            raise ValueError(f"Start address must be aligned to word size {wordsize}")

        bisect_cache = list(i.address for i in cache)
        start_offset = bisect.bisect(bisect_cache, start_address)
        workinglist = deque(cache[start_offset:])

        matches = []
        while workinglist:
            invocation_list = list(itertools.islice(workinglist, 0, len(condition_lambdas)))
            invocations = [not isinstance(i, SentinelInstruction) and l(i, i.address - self.base_address) for i, l in zip(invocation_list, condition_lambdas)]
            if all(invocations):
                matched_address = invocation_list[0].address
                matched_offset = matched_address - self.base_address
                matched_instructions = invocation_list if after_match_count is None else list(itertools.islice(workinglist, 0, len(condition_lambdas) + after_match_count))
                match = CodePatternMatch(matched_instructions=matched_instructions, start_address=matched_address, start_offset=matched_offset)
                if stop_at_first:
                    return [match]
                else:
                    matches.append(match)

            workinglist.popleft()
        
        return matches

    def bytecode_search(self, bytecode: bytes, stop_at_first: bool = True):
        offset = self.code.find(bytecode, 0)

        if offset == -1:
            return []

        matches = [self.base_address + offset]
        if stop_at_first:
            return matches

        offset = self.code.find(bytecode, offset+1)
        while offset != -1:
            matches.append(self.base_address + offset)
            offset = self.code.find(bytecode, offset+1)

        return matches

    def set_final_thumb_offset(self, address):
        # Because we're only scanning the app partition, we must add the offset for the bootloader
        # Also add an offset of 1 for the THUMB
        return address + 0x10000 + 1

    def __build_cache(self, thumb_mode: bool):
        mode = CS_MODE_THUMB if thumb_mode else CS_MODE_ARM
        md = Cs(CS_ARCH_ARM, mode)
        md.detail = True
        wordsize = self.__get_wordsize(thumb_mode)

        cache = []
        offset = 0
        sentinel_size = 0
        while offset < len(self.code):
            address = offset + self.base_address
            instrs = list(md.disasm(self.code[offset:], offset=address))
            increment = sum((i.size for i in instrs)) or wordsize
            if instrs:
                cache.extend(instrs)
                if sentinel_size:
                    cache.append(SentinelInstruction(address=(address-sentinel_size), size=sentinel_size))
                    sentinel_size = 0
            else:
                sentinel_size += wordsize
            offset += increment

        return cache

    def __get_wordsize(self, thumb_mode: bool):
        return 2 if thumb_mode else 4

def name_output_file(desired_appended_name):
    # File generated by bk7321tools dissect_dump
    if appcode_path.endswith('app_1.00_decrypted.bin'):
        return appcode_path.replace('app_1.00_decrypted.bin', desired_appended_name)
    return appcode_path + "_" + desired_appended_name

def walk_app_code():
    # Older versions of BK7231T, BS version 30.0x, SDK 2.0.0
    if b'TUYA IOT SDK V:2.0.0' in appcode and b'AT 8710_2M' in appcode:
        # 04 1e 07 d1 11 9b 21 1c 00 is the byte pattern for datagram payload
        # 3 matches, 2nd is correct
        # 2b 68 30 1c 98 47 is the byte pattern for finish addess
        # 1 match should be found
        process_generic("BK7231T", 1, "datagram", "041e07d1119b211c00", 3, 1, "2b68301c9847", 1, 0)
        return

    # Newer versions of BK7231T, BS 40.00, SDK 1.0.x
    if b'TUYA IOT SDK V:1.0.' in appcode and b'AT bk7231t' in appcode:
        # a1 4f 06 1e is the byte pattern for datagram payload
        # 1 match should be found
        # 23 68 38 1c 98 47 is the byte pattern for finish addess
        # 2 matches should be found, 1st is correct
        process_generic("BK7231T", 2, "datagram", "a14f061e", 1, 0, "2368381c9847", 2, 0)
        return

    # Newest versions of BK7231T, BS 40.00, SDK 2.3.2
    if b'TUYA IOT SDK V:2.3.2 BS:40.00_PT:2.2_LAN:3.3_CAD:1.0.4_CD:1.0.0' in appcode:
        # TODO: Figure out how to process this format
        raise RuntimeError("This device uses SDK 2.3.2 and there is currently no pattern to mach it.")
        #process_generic("BK7231T", 3, "", "041e00d10ce7", 1, 0, "", 0, 0)
        return

    # BK7231N, BS 40.00, SDK 2.3.1
    # 0.0.2 is also a variant of 2.3.1
    if (b'TUYA IOT SDK V:2.3.1 BS:40.00_PT:2.2_LAN:3.3_CAD:1.0.3_CD:1.0.0' in appcode
        or b'TUYA IOT SDK V:0.0.2 BS:40.00_PT:2.2_LAN:3.3_CAD:1.0.3_CD:1.0.0' in appcode):
        # 05 1e 00 d1 15 e7 is the byte pattern for ssid payload
        # 1 match should be found
        # 43 68 20 1c 98 47 is the byte pattern for finish address
        # 1 match should be found
        process_generic("BK7231N", 1, "ssid", "051e00d115e7", 1, 0, "4368201c9847", 1, 0)
        return

    # BK7231N, BS 40.00, SDK 2.3.3
    if b'TUYA IOT SDK V:2.3.3 BS:40.00_PT:2.2_LAN:3.4_CAD:1.0.5_CD:1.0.0' in appcode:
        # 05 1e 00 d1 fc e6 is the byte pattern for ssid payload
        # 1 match should be found
        # 43 68 20 1c 98 47 is the byte pattern for finish address
        # 1 match should be found
        process_generic("BK7231N", 2, "ssid", "051e00d1fce6", 1, 0, "4368201c9847", 1, 0)
        return

    raise RuntimeError('Unknown pattern, please open a new issue and include the bin.')

def process_generic(chipset, pattern_version, payload_type, payload_string, payload_count, payload_index, finish_string, finish_count, finish_index):
    matcher = CodePatternFinder(appcode, 0x0)
    print(f"[+] Matched pattern for {chipset} version {pattern_version}, payload type {payload_type}")

    print(f"[+] Searching for {payload_type} payload address")
    payload_bytecode = bytes.fromhex(payload_string)
    payload_matches = matcher.bytecode_search(payload_bytecode, stop_at_first=False)
    if not payload_matches or len(payload_matches) != payload_count:
        raise RuntimeError(f"[!] Failed to find {payload_type} payload address (found {len(payload_matches)}, expected {payload_count})")
    payload_addr = matcher.set_final_thumb_offset(payload_matches[payload_index])
    for b in payload_addr.to_bytes(3, byteorder='little'):
        if b == 0:
            raise RuntimeError(f"[!] {payload_type} payload address contains a null byte, unable to continue")
    print(f"[+] {payload_type} payload address gadget (THUMB): 0x{payload_addr:X}")

    print("[+] Searching for finish address")
    finish_bytecode = bytes.fromhex(finish_string)
    finish_matches = matcher.bytecode_search(finish_bytecode, stop_at_first=False)
    if not finish_matches or len(finish_matches) > finish_count:
        raise RuntimeError("[!] Failed to find finish address")
    finish_addr = matcher.set_final_thumb_offset(finish_matches[finish_index])
    for b in finish_addr.to_bytes(3, byteorder='little'):
        if b == 0:
            if finish_count > 0:
                print("[!] Preferred finish address contained a null byte, using available alternative")
                finish_addr = matcher.set_final_thumb_offset(finish_matches[finish_index + 1])
            else:
                raise RuntimeError("[!] Finish address contains a null byte, unable to continue")
    print(f"[+] Finish address gadget (THUMB): 0x{finish_addr:X}")
    
    with open(name_output_file('chip.txt'), 'w') as f:
        f.write(f'{chipset}')
    with open(name_output_file('address_finish.txt'), 'w') as f:
        f.write(f'0x{finish_addr:X}')

    if payload_type == "datagram":
        with open(name_output_file('address_datagram.txt'), 'w') as f:
            f.write(f'0x{payload_addr:X}')
    elif payload_type == "ssid":
        with open(name_output_file('address_ssid.txt'), 'w') as f:
            f.write(f'0x{payload_addr:X}')
    elif payload_type == "passwd":
        with open(name_output_file('address_passwd.txt'), 'w') as f:
            f.write(f'0x{payload_addr:X}')

def run(decrypted_app_file: str):
    if not decrypted_app_file:
        print('Usage: python haxomatic.py <app code file>')
        sys.exit(1)

    address_finish_file = decrypted_app_file.replace('_app_1.00_decrypted.bin', '_address_finish.txt')
    if os.path.exists(address_finish_file):
        print('[+] Haxomatic has already been run')
        return

    global appcode_path, appcode
    appcode_path = decrypted_app_file
    with open(appcode_path, 'rb') as fs:
        appcode = fs.read()
        walk_app_code()

if __name__ == '__main__':
    run(sys.argv[1])
